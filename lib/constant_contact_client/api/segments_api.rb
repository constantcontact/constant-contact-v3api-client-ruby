=begin
#Constant Contact API v3

#Swagger build version 3.0.2475

The version of the OpenAPI document: 1.0.109
Contact: webservices@constantcontact.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 7.2.0

=end

require 'cgi'

module ConstantContactClient
  class SegmentsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # POST (create) a Segment
    # Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment `name` must be unique. The `segment_criteria` requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the `segment_criteria` to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **`tracking`**: Supports **or** and **and** groups.     -  **`contact`**: Supports **or** and **and** groups.     -  **`list_membership`**: Supports **or** groups.    -  **`tags`**: Supports **or** groups.  If you do not specify `list_membership` as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
    # @param create_segment_request [CreateSegmentRequest] The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
    # @param [Hash] opts the optional parameters
    # @return [CreateSegment201Response]
    def create_segment(create_segment_request, opts = {})
      data, _status_code, _headers = create_segment_with_http_info(create_segment_request, opts)
      data
    end

    # POST (create) a Segment
    # Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment &#x60;name&#x60; must be unique. The &#x60;segment_criteria&#x60; requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the &#x60;segment_criteria&#x60; to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **&#x60;tracking&#x60;**: Supports **or** and **and** groups.     -  **&#x60;contact&#x60;**: Supports **or** and **and** groups.     -  **&#x60;list_membership&#x60;**: Supports **or** groups.    -  **&#x60;tags&#x60;**: Supports **or** groups.  If you do not specify &#x60;list_membership&#x60; as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the &#x60;segment_criteria&#x60; do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
    # @param create_segment_request [CreateSegmentRequest] The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateSegment201Response, Integer, Hash)>] CreateSegment201Response data, response status code and response headers
    def create_segment_with_http_info(create_segment_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.create_segment ...'
      end
      # verify the required parameter 'create_segment_request' is set
      if @api_client.config.client_side_validation && create_segment_request.nil?
        fail ArgumentError, "Missing the required parameter 'create_segment_request' when calling SegmentsApi.create_segment"
      end
      # resource path
      local_var_path = '/segments'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_segment_request)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateSegment201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.create_segment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#create_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # DELETE a Segment
    # Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the `GET /segments` endpoint. If you know the `segment_id`, you can use the `GET /segments/{segment_id}` endpoint to view the deleted segment's details. A segment's details are preserved for external reference purposes, such as displaying the segment name in a campaign's history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_segment(segment_id, opts = {})
      delete_segment_with_http_info(segment_id, opts)
      nil
    end

    # DELETE a Segment
    # Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the &#x60;GET /segments&#x60; endpoint. If you know the &#x60;segment_id&#x60;, you can use the &#x60;GET /segments/{segment_id}&#x60; endpoint to view the deleted segment&#39;s details. A segment&#39;s details are preserved for external reference purposes, such as displaying the segment name in a campaign&#39;s history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_segment_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.delete_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.delete_segment"
      end
      # resource path
      local_var_path = '/segments/{segment_id}'.sub('{' + 'segment_id' + '}', CGI.escape(segment_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.delete_segment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#delete_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # GET all Segments
    # Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :limit The number of segments to return on a page. (default to '1000')
    # @option opts [String] :sort_by Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first. (default to 'date')
    # @return [GetAllSegments200Response]
    def get_all_segments(opts = {})
      data, _status_code, _headers = get_all_segments_with_http_info(opts)
      data
    end

    # GET all Segments
    # Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :limit The number of segments to return on a page. (default to '1000')
    # @option opts [String] :sort_by Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first. (default to 'date')
    # @return [Array<(GetAllSegments200Response, Integer, Hash)>] GetAllSegments200Response data, response status code and response headers
    def get_all_segments_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_all_segments ...'
      end
      # resource path
      local_var_path = '/segments'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'sort_by'] = opts[:'sort_by'] if !opts[:'sort_by'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAllSegments200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.get_all_segments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_all_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # GET a Segment's Details
    # Use this method to get details about a segment, including the segment criteria. If you know the `segment_id` You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment's Details](/api_guide/segment_get.html) in the API guide.
    # @param segment_id [Integer] The system-generated unique ID that identifies a segment.
    # @param [Hash] opts the optional parameters
    # @return [CreateSegment201Response]
    def get_segment_by_id(segment_id, opts = {})
      data, _status_code, _headers = get_segment_by_id_with_http_info(segment_id, opts)
      data
    end

    # GET a Segment&#39;s Details
    # Use this method to get details about a segment, including the segment criteria. If you know the &#x60;segment_id&#x60; You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment&#39;s Details](/api_guide/segment_get.html) in the API guide.
    # @param segment_id [Integer] The system-generated unique ID that identifies a segment.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateSegment201Response, Integer, Hash)>] CreateSegment201Response data, response status code and response headers
    def get_segment_by_id_with_http_info(segment_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.get_segment_by_id ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.get_segment_by_id"
      end
      # resource path
      local_var_path = '/segments/{segment_id}'.sub('{' + 'segment_id' + '}', CGI.escape(segment_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CreateSegment201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.get_segment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#get_segment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # PUT (update) a Segment
    # Use this method to update an existing segment's name (`name`) and/or contact selection criteria (`segment_criteria`). You must specify both the `name` and the `segment_criteria` in the request body, even if you don't plan to update both. The segment's name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment that you want to modify.
    # @param create_segment_request [CreateSegmentRequest] Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
    # @param [Hash] opts the optional parameters
    # @return [CreateSegment201Response]
    def update_segment(segment_id, create_segment_request, opts = {})
      data, _status_code, _headers = update_segment_with_http_info(segment_id, create_segment_request, opts)
      data
    end

    # PUT (update) a Segment
    # Use this method to update an existing segment&#39;s name (&#x60;name&#x60;) and/or contact selection criteria (&#x60;segment_criteria&#x60;). You must specify both the &#x60;name&#x60; and the &#x60;segment_criteria&#x60; in the request body, even if you don&#39;t plan to update both. The segment&#39;s name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the &#x60;segment_criteria&#x60; do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment that you want to modify.
    # @param create_segment_request [CreateSegmentRequest] Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateSegment201Response, Integer, Hash)>] CreateSegment201Response data, response status code and response headers
    def update_segment_with_http_info(segment_id, create_segment_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_segment ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_segment"
      end
      # verify the required parameter 'create_segment_request' is set
      if @api_client.config.client_side_validation && create_segment_request.nil?
        fail ArgumentError, "Missing the required parameter 'create_segment_request' when calling SegmentsApi.update_segment"
      end
      # resource path
      local_var_path = '/segments/{segment_id}'.sub('{' + 'segment_id' + '}', CGI.escape(segment_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_segment_request)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateSegment201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.update_segment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_segment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # PATCH (rename) a Segment
    # Use this method to update an existing segment `name` with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment that you want to modify.
    # @param update_segment_name_request [UpdateSegmentNameRequest] Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
    # @param [Hash] opts the optional parameters
    # @return [CreateSegment201Response]
    def update_segment_name(segment_id, update_segment_name_request, opts = {})
      data, _status_code, _headers = update_segment_name_with_http_info(segment_id, update_segment_name_request, opts)
      data
    end

    # PATCH (rename) a Segment
    # Use this method to update an existing segment &#x60;name&#x60; with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
    # @param segment_id [Integer] The system generated ID that uniquely identifies the segment that you want to modify.
    # @param update_segment_name_request [UpdateSegmentNameRequest] Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateSegment201Response, Integer, Hash)>] CreateSegment201Response data, response status code and response headers
    def update_segment_name_with_http_info(segment_id, update_segment_name_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SegmentsApi.update_segment_name ...'
      end
      # verify the required parameter 'segment_id' is set
      if @api_client.config.client_side_validation && segment_id.nil?
        fail ArgumentError, "Missing the required parameter 'segment_id' when calling SegmentsApi.update_segment_name"
      end
      # verify the required parameter 'update_segment_name_request' is set
      if @api_client.config.client_side_validation && update_segment_name_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_segment_name_request' when calling SegmentsApi.update_segment_name"
      end
      # resource path
      local_var_path = '/segments/{segment_id}/name'.sub('{' + 'segment_id' + '}', CGI.escape(segment_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_segment_name_request)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateSegment201Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2_access_code', 'oauth2_implicit']

      new_options = opts.merge(
        :operation => :"SegmentsApi.update_segment_name",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SegmentsApi#update_segment_name\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
